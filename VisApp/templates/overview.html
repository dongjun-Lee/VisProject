{% extends 'base.html' %}
{% block css %}
<style>

svg {
  font: 10px sans-serif;
  padding: 10px;
}

.axis,
.frame {
  shape-rendering: crispEdges;
}

.axis line {
  stroke: #ddd;
}

.axis path {
  display: none;
}

.cell text {
  font-weight: bold;
  text-transform: capitalize;
}

.frame {
  fill: none;
  stroke: #aaa;
}

circle {
  fill-opacity: .7;
}

circle.not-selected {
  fill: #ccc !important;
}

.extent {
  fill: #000;
  fill-opacity: .125;
  stroke: #fff;
}

</style>	  
{% endblock %}


{% block body %}
  <div id="page-wrapper">
    <div class="container-fluid">
      <div class="row">
        <div class="col-lg-12">
          <h1 class="page-header">Overview</h1>
        </div>
      </div>
    </div>
  </div>

  <div class="btn-group" data-toggle="buttons">
	  <label class="btn btn-primary active">
	    <input type="radio" name="options" id="option1" value="option1" autocomplete="off" checked> Summary Table
	  </label>
	  <label class="btn btn-primary">
	    <input type="radio" name="options" id="option2" value="option2" autocomplete="off"> Scatter Plot Matrix
	  </label>
	  <label class="btn btn-primary">
	    <input type="radio" name="options" id="option3" value="option3" autocomplete="off"> Histogram
	  </label>
  </div>

  </br>

  <div class="table_area">
  </br>
  </br>
  	<div class="real_table_area"> </div>
  </div>

  <div class="scatter_plot_area">
  </div>

  <div class="histogram_area">
  	<p>hello ^^</p>
  </div>

  <script>
		$('.table_area').show();
		$('.scatter_plot_area').hide();
		$('.histogram_area').hide();

  	drawSummaryTable();
  	drawScatterPlot();

  	$("input[name='options']").change(function(d){
  		console.log($(this).val());
  		var option = $(this).val();
  		if (option=="option1") {
  			$('.table_area').show();
  			$('.scatter_plot_area').hide();
  			$('.histogram_area').hide();
  		} else if (option=="option2") {
  			$('.table_area').hide();
  			$('.scatter_plot_area').show();
  			$('.histogram_area').hide();
  		} else {
  			$('.table_area').hide();
  			$('.scatter_plot_area').hide();
  			$('.histogram_area').show();
  		}
  	});
    

  	
  	function drawHistogram() {
  		console.log("drawHistogram!");
  	}


  	function drawSummaryTable() {
	    var tabulate = function (data,columns) {
	      var table = d3.select("body").select("div.real_table_area").append("table")
	      	.attr("class", "table");
	      var thead = table.append('thead');
	      var tbody = table.append('tbody');

	      var tr = thead.append('tr');
	      tr.append('th').text("Column");
	      tr.append('th').text("Avg");
	      tr.append('th').text("Min");
	      tr.append('th').text("Max");
	      tr.append('th').text("Median");
	      tr.append('th').text("StdDev");

	      for (i in columns) {
	      	console.log(columns[i]);
	      	var tr = tbody.append('tr');
	      	var avg = d3.mean(data, function(d){return parseFloat(d[columns[i]])});
	      	var min = d3.min(data, function(d){return parseFloat(d[columns[i]])});
	      	var max = d3.max(data, function(d){return parseFloat(d[columns[i]])});
	      	//var min = d3.min(data, function(d){return d.x});
	      	//var max = d3.max(data, function(d){return d.columns[i]});
	      	var median = d3.median(data, function(d){return parseFloat(d[columns[i]])});
	      	var stddev = d3.deviation(data, function(d){return parseFloat(d[columns[i]])});
	      	tr.append('td').text(columns[i]);
	      	tr.append('td').text(avg.toFixed(2));
	      	tr.append('td').text(min.toFixed(2));
	      	tr.append('td').text(max.toFixed(2));
	      	tr.append('td').text(median.toFixed(2));
	      	tr.append('td').text(stddev.toFixed(2));
	      }


	      // thead.append('tr')
	      //   .selectAll('td')
	      //     .data(columns)
	      //     .enter()
	      //   .append('th')
	      //     .text(function (d) { return d })

	      // var rows = tbody.selectAll('tr')
	      //     .data(data)
	      //     .enter()
	      //   .append('tr')

	      // var cells = rows.selectAll('td')
	      //     .data(function(row) {
	      //       return columns.map(function (column) {
	      //         return { column: column, value: row[column] }
	      //       })
	      //     })
	      //     .enter()
	      //   .append('td')
	      //     .text(function (d) { return d.value })

	      return table;

	    }

	    d3.csv("/media/data.csv", function(data) {
	      var columns = d3.keys(data[0]);
	      tabulate(data, columns);
	    });

  	}


  	function drawScatterPlot() {
  		var width = 960,
		    size = 230,
		    padding = 40;

			var x = d3.scale.linear()
			    .range([padding / 2, size - padding / 2]);

			var y = d3.scale.linear()
			    .range([size - padding / 2, padding / 2]);

			var xAxis = d3.svg.axis()
			    .scale(x)
			    .orient("bottom")
			    .ticks(6);

			var yAxis = d3.svg.axis()
			    .scale(y)
			    .orient("left")
			    .ticks(6);

			var color = d3.scale.category10();

			d3.csv("/media/flowers.csv", function(error, data) {
			  if (error) throw error;

			  var domainByTrait = {},
			      traits = d3.keys(data[0]).filter(function(d) { return d !== "class_label"; }),
			      n = traits.length;

			  traits.forEach(function(trait) {
			    domainByTrait[trait] = d3.extent(data, function(d) { return d[trait]; });
			  });

			  xAxis.tickSize(size * n);
			  yAxis.tickSize(-size * n);

			  var brush = d3.svg.brush()
			      .x(x)
			      .y(y)
			      .on("brushstart", brushstart)
			      .on("brush", brushmove)
			      .on("brushend", brushend);

			  var svg = d3.select("body").select("div.scatter_plot_area").append("svg")
			      .attr("width", size * n + padding)
			      .attr("height", size * n + padding)
			    .append("g")
			      .attr("transform", "translate(" + padding + "," + padding / 2 + ")");

			  svg.selectAll(".x.axis")
			      .data(traits)
			    .enter().append("g")
			      .attr("class", "x axis")
			      .attr("transform", function(d, i) { return "translate(" + (n - i - 1) * size + ",0)"; })
			      .each(function(d) { x.domain(domainByTrait[d]); d3.select(this).call(xAxis); });

			  svg.selectAll(".y.axis")
			      .data(traits)
			    .enter().append("g")
			      .attr("class", "y axis")
			      .attr("transform", function(d, i) { return "translate(0," + i * size + ")"; })
			      .each(function(d) { y.domain(domainByTrait[d]); d3.select(this).call(yAxis); });

			  var cell = svg.selectAll(".cell")
			      .data(cross(traits, traits))
			    .enter().append("g")
			      .attr("class", "cell")
			      .attr("transform", function(d) { return "translate(" + (n - d.i - 1) * size + "," + d.j * size + ")"; })
			      .each(plot);

			  // Titles for the diagonal.
			  cell.filter(function(d) { return d.i === d.j; }).append("text")
			      .attr("x", padding)
			      .attr("y", padding)
			      .attr("dy", ".71em")
			      .text(function(d) { return d.x; });

			  cell.call(brush);

			  function plot(p) {
			    var cell = d3.select(this);

			    x.domain(domainByTrait[p.x]);
			    y.domain(domainByTrait[p.y]);

			    cell.append("rect")
			        .attr("class", "frame")
			        .attr("x", padding / 2)
			        .attr("y", padding / 2)
			        .attr("width", size - padding)
			        .attr("height", size - padding);

			    cell.selectAll("circle")
			        .data(data)
			      .enter().append("circle")
			        .attr("cx", function(d) { return x(d[p.x]); })
			        .attr("cy", function(d) { return y(d[p.y]); })
			        .attr("r", 4)
			  }

			  var brushCell;

			  // Clear the previously-active brush, if any.
			  function brushstart(p) {
			    if (brushCell !== this) {
			      d3.select(brushCell).call(brush.clear());
			      x.domain(domainByTrait[p.x]);
			      y.domain(domainByTrait[p.y]);
			      brushCell = this;
			    }
			  }

			  // Highlight the selected circles.
			  function brushmove(p) {
			    var e = brush.extent();
			    svg.selectAll("circle").classed("not-selected", function(d) {
			      return e[0][0] > d[p.x] || d[p.x] > e[1][0]
			          || e[0][1] > d[p.y] || d[p.y] > e[1][1];
			    });
			  }

			  // If the brush is empty, select all circles.
			  function brushend() {
			    if (brush.empty()) svg.selectAll(".not-selected").classed("not-selected", false);
			  }
			});

			function cross(a, b) {
			  var c = [], n = a.length, m = b.length, i, j;
			  for (i = -1; ++i < n;) for (j = -1; ++j < m;) c.push({x: a[i], i: i, y: b[j], j: j});
			  return c;
			}

  	}
		
	</script>


{% endblock %}











